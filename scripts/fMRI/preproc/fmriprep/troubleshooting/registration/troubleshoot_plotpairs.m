function X=troubleshoot_plotpairs(images, type, varargin)
% Plots an image of a correlation matrix with circles, text, image, or combinations
%
% :Usage:
% ::
%
%     OUT = troubleshoot_plotpairs(images, [optional inputs])
%
% - Can do full or partial correlations, Spearman or Pearson's
% - FDR correction across pairwise tests if desired.
%
% For objects: Type methods(object_name) for a list of special commands
%              Type help object_name.method_name for help on specific
%              methods.
%
% ..
%     Author and copyright information:
%
%     Copyright (C) 2023 Michael Sun
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <http://www.gnu.org/licenses/>.
% ..
%
% :Inputs:
%
%   **images:**
%        You can pass in a root directory that contains images. May be a valid BIDS
%        directory. Recommendation is to generate a directory of mean
%        images using study_means.sbatch.
%
%        Future functionality may consider allowing passing in a cell array of image paths, or an fmri_data
%        object. Specify what the images argument is in type.
%
%   **type:**
%        Choices are:
%           'bidsdir' (BIDS Directory), 'meansdir' (Directory of images
%           generated by study_means.sbatch). 
%           Future functionality consider 'cell', and/or 'fmri_data'.
%
% :Optional Inputs:
%   **thr:**
%        Correlation threshold for determining good and bad scans. Range between -1 and 1. Default
%        is 0.9.
%
%   **remove_outliers:**
%        Don't include outlier scans in troubleshooting comparisons.
%
% :Outputs:
%
%   **X:**
%        structure with various outputs
%       - r: Correlation matrix
%       - p, sig: P-value and significance <.05
%       - m: cell array of fmri_dat mean images
%       - t: Pairwise Image Correlation Table
%       - t_noout: Pairwise Image Correlation Table, sans Outliers
%       - out_nocorr: Outlier Images, Uncorrected for Multiple Comparisons
%       - out_corr: Outlier Images, Corrected for Multiple Comparisons

remove_outliers=0;
thr=0.9;

if any(strcmp(varargin, 'remove_outliers'))
    remove_outliers=1;
end

for varg = 1:length(varargin)
    if strcmp(varargin{varg}, 'thr')
        thr=varargin{varg+1};
    end
end


    %% Housekeeping: Create a list of funcfiles

    if strcmp(type, 'bidsdir')
        cd(images)
    
        % subjects = canlab_list_subjects(fmriprep_dir, 'sub-*');
        % funcfiles={};
        % fnames={};
        % for s = 1:numel(subjects)
        %     % Check if there are multiple sessions per subject, then create a
        %     % cell-array with all the bold data
        %     sessions=canlab_list_subjects(fullfile(fmriprep_dir, subjects{s}), 'ses-*');
        %     if ~isempty(sessions)
        %         for ses = 1:numel(sessions)
        %             % funcfiles{s}{ses}=dir(fullfile(fmriprep_dir, subjects{s}, sessions{ses}, 'func', '*_bold.nii.gz'));
        %             % fnames{s}{ses}={funcfiles{s}{ses}.name}';
        %             % funcfiles{s}{ses}=fullfile({funcfiles{s}{ses}.folder}',{funcfiles{s}{ses}.name}');
        % 
        %             funcfiles{end+1}=dir(fullfile(fmriprep_dir, subjects{s}, sessions{ses}, 'func', '*_bold.nii.gz'));
        %             fnames{end+1}={funcfiles{s}.name}';
        %             funcfiles{end+1}=fullfile({funcfiles{s}.folder}',{funcfiles{s}.name}');
        %         end
        %     else
        %             funcfiles{s}=dir(fullfile(fmriprep_dir, subjects{s}, 'func', '*_bold.nii.gz'));
        %             fnames{s}={funcfiles{s}.name}';
        %             funcfiles{s}=fullfile({funcfiles{s}.folder}',{funcfiles{s}.name}');
        %     end
        % end
        
        subjects = canlab_list_subjects(images, 'sub-*');
        funcfiles={};
        fnames={};
        for s = 1:numel(subjects)
            funcfiles{s}=dir(fullfile(images, subjects{s}, 'func', '*_bold.nii.gz'));
            fnames{s}={funcfiles{s}.name}';
            funcfiles{s}=fullfile({funcfiles.folder}',{funcfiles.name}');
        end
    
        % Generating Mean images from all of the raw data can take a long time. 
        % Best do this on a cluster HPC like Discovery (use study_means.sbatch).
        % Doing it this way took about 1.5 hours for 40 images, parallelized with 4 workers.
        
        warning('Generating all mean images from raw data can take a long time. I recommend using an HPC batch job like study_means.sbatch.');
    
        % Ask the user if they want to continue
        userInput = input('Do you want to continue? (y/n): ', 's');
        
        % Check the user's response
        if strcmpi(userInput, 'y') || strcmpi(userInput, 'yes')
            % User wants to continue, do nothing
        else
            % User wants to abort, stop the program
            error('Program aborted by user.');
        end
    
        %% Generate data from files and mean images
    
        tic
        parpool();
        
        parfor f=1:numel(funcfiles)
            dat=fmri_data(funcfiles{f});
            m_array{f}=mean(dat);
            m_array{f}.fullpath= funcfiles{f};
            m_array{f}.image_names= fnames{f};
        end
        toc
        
        delete(gcp);
    
    
    elseif strcmp(type, 'meansdir')
        % Read-in mean images pre-generated with study_means.sbatch
        % means_dir=varargin{1};
        subjects=canlab_list_subjects(images, 'sub-*');
        funcfiles={};
        fnames={};
    
        if ~isempty(subjects)
            for s = 1:numel(subjects)
                funcfiles{s}=dir(fullfile(images, subjects{s}, '*.nii'));
                fnames{s}={funcfiles{s}.name}';
                funcfiles{s}=fullfile({funcfiles{s}.folder}',{funcfiles{s}.name}');
            end
        else
            % All 1 subject?
            funcfiles{1}=dir(fullfile(images, '*.nii'));
            fnames{1}={funcfiles{1}.name}';
            funcfiles{1}=fullfile({funcfiles{1}.folder}',{funcfiles{1}.name}');
        end
        
        parpool();
        tic
        parfor s=1:numel(funcfiles)
            m_array{s}=fmri_data(funcfiles{s});
        end
        toc
        % Took 10 minutes.
       
        delete(gcp);
    
    end


    %% Generate mean data matrix to pass into plot_correlation_matrix()
    
    % m_dat=[]
    % for f=1:numel(m_array)
    %     if f ==1
    %         m_dat=m_array{f}.dat';
    %     else
    %         [m1, m2]=padwithnan(m_dat, m_array{f}.dat', 2);
    %         m_dat=[m1'; m2'];
    %     end
    % end

    for sub=1:numel(funcfiles)
        
        [wh_outlier_uncorr{sub}, wh_outlier_corr{sub}, X{sub}] = plot(m_array{sub}, 'noorthviews');
    
        if sum(wh_outlier_uncorr{sub})~=0
            outlier_scans{sub}=get_wh_image(m_array{sub}, find(wh_outlier_uncorr{sub}==1));
            outlier_names{sub}=outlier_scans{sub}.image_names;
        end

        figure;
        OUT{sub}=plot_correlation_matrix(X{sub}, 'var_names', fnames{sub}, 'nofigure');
        if ~isempty(subjects)
            title('Pairwise Corregram of Images from ', subjects{sub});
        else
            title('Pairwise Corregram of Images');
        end

        %% Generate all filename pairs
        % fname_pairs={}
        % for j = 1:numel(fnames)
        %     for i = 1:numel(fnames)
        %         fname_pairs{end+1}=[fnames{r}, ' x ' fnames{c}];
        %     end
        % end
    
        pairidx{sub}=combnk(1:numel(fnames{sub}), 2);
        pairs{sub}=combnk(fnames{sub}, 2);
    
        % Extract the two columns as separate cell arrays
        col1{sub} = pairs{sub}(:, 1);
        col2{sub} = pairs{sub}(:, 2);
    
        idx=sub2ind(size(OUT{sub}.r), pairidx{sub}(:, 1), pairidx{sub}(:, 2));
    
        %% Generate Correlation Table of All Image Pairs
        % t=table(pairnames, OUT.r(idx), 'VariableNames', {'Image Pair', 'Correlation'})
    
        t{sub}=table(col1{sub}, col2{sub}, OUT{sub}.r(idx), 'VariableNames', {'Image1', 'Image2', 'Correlation'});
        [t{sub}, order{sub}]=sortrows(t{sub}, 'Correlation', 'ascend');
    
        % Remove Outlier Images since those will be poorly correlated with all images.    
        
        if sum(wh_outlier_uncorr{sub})~=0
            logicalIdx = logical(ismember(t{sub}.('Image1'), outlier_names{sub}) + ismember(t{sub}.('Image2'), outlier_names{sub}));
            t_nooutliers{sub} = t{sub};
            t_nooutliers{sub}(logicalIdx, :) = [];
        else
            t_nooutliers{sub} = t{sub};
        end
    
        bad_pair{sub}=find(t_nooutliers{sub}.Correlation<thr);
    
        %% Display Worst Image-Pairs
        if isempty(bad_pair{sub})
            disp(['All Images Correlated at least ', thr]);
        end


        if ~isempty(subjects)
            sprintf([subjects{sub}, ' Worst Image-Pairs']);
            create_figure(['Bad Image-Pairs ', subjects{sub}],3,3);
        else
            sprintf('Worst Image-Pairs');
            create_figure('Bad Image-Pairs',3,3);
        end
        
        t1=tiledlayout(3,3, 'TileSpacing', 'compact');

        for img_pair = 1:numel(bad_pair{sub})

            if remove_outliers==1
                dat1=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t_nooutliers{sub}.Image1{img_pair})));
                dat2=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t_nooutliers{sub}.Image2{img_pair})));
            else
                dat1=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t{sub}.Image1{img_pair})));
                dat2=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t{sub}.Image2{img_pair})));
            end

            montage_pair_means(dat1, dat2);
    
            if img_pair==3
                break
            end
        end
        if ~isempty(subjects)
            title(t1, ['Worst 3 Image-Pairs of ', subjects{sub}]);
        else
            title(t1, 'Worst 3 Image-Pairs');
        end
        drawnow;
    
    
        %% Display Best Image-Pairs
        if ~isempty(subjects)
            sprintf([subjects{sub}, ' Best Image-Pairs']);
            create_figure(['Good Image-Pairs ', subjects{sub}],3,3);
        else
            sprintf('Best Image-Pairs');
            create_figure('Good Image-Pairs',3,3);
        end

        t2=tiledlayout(3,3, 'TileSpacing', 'compact');
        for img_pair = 1:height(t{sub})
            if remove_outliers==1
                dat1=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t_nooutliers{sub}.Image1{end+1-img_pair})));
                dat2=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t_nooutliers{sub}.Image2{end+1-img_pair})));
            else
                dat1=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t{sub}.Image1{end+1-img_pair})));
                dat2=get_wh_image(m_array{sub}, find(contains(funcfiles{sub}, t{sub}.Image2{end+1-img_pair})));
            end

            montage_pair_means(dat1, dat2);
            if img_pair==3
                break
            end
        end
    
        if ~isempty(subjects)
            title(t2, ['Best 3 Image-Pairs of ', subjects{sub}]);
        else
            title(t2, 'Best 3 Image-Pairs');
        end

        drawnow;

        %% Display all Outlier Images

        % Uncorrected Outliers:
        if sum(wh_outlier_uncorr{sub})~=0
            if ~isempty(subjects)
                sprintf([subjects{sub}, ' Outliers, Uncorrected']);
                create_figure(['Outlier Images for ', subjects{sub}, ' Uncorrected']);
            else
                sprintf('Outliers, Uncorrected');
                create_figure('Outliers, Uncorrected');
            end
            t3=tiledlayout('vertical', 'TileSpacing', 'compact');
    
            alldat = outlier_scans{sub}.dat(:);
            clim = [mean(alldat, 'omitnan') - 3*std(alldat, 'omitnan') mean(alldat, 'omitnan') + 3*std(alldat, 'omitnan')];
    
            for o = 1:size(outlier_scans{sub}.dat, 2)
                nexttile
        
                img=get_wh_image(outlier_scans{sub}, o);
                han = display_slices(img, 'axial', 'slices_per_row', 10, 'spacing', 8, 'startslice', -30, 'endslice', 40, 'clim', clim);
                if isempty(img.image_names)
                    title(sprintf('Image 1'))
                else
                    t{o}=format_strings_for_legend(img.image_names(1,:));
                    title(t{o});
                end
            end
    
            if ~isempty(subjects)
                title(t3, ['Uncorrected Outliers of ', subjects{sub}]);
            else
                title(t3, 'Uncorrected Outliers');
            end
    
            drawnow;
        end

        % Outliers, Post-Multiple Comparison Correction:
        if sum(wh_outlier_corr{sub})~=0
            outlier_scans_corr{sub}=get_wh_image(m_array{sub}, find(wh_outlier_corr{sub}==1));
            outlier_names_corr{sub}=outlier_scans_corr{sub}.image_names;

            if ~isempty(subjects)
                sprintf([subjects{sub}, ' Outliers, Post-Correction']);
                create_figure(['Outlier Images for ', subjects{sub}, ' Post-Correction']);
            else
                sprintf('Outliers, Post-Correction');
                create_figure('Outliers, Post-Correction');
            end
            t4=tiledlayout('vertical', 'TileSpacing', 'compact');
    
            alldat = outlier_scans_corr{sub}.dat(:);
            clim = [mean(alldat, 'omitnan') - 3*std(alldat, 'omitnan') mean(alldat, 'omitnan') + 3*std(alldat, 'omitnan')];
    
            for o = 1:size(outlier_scans_corr{sub}.dat, 2)
                nexttile
        
                img=get_wh_image(outlier_scans_corr{sub}, o);
                han = display_slices(img, 'axial', 'slices_per_row', 10, 'spacing', 8, 'startslice', -30, 'endslice', 40, 'clim', clim);
                if isempty(img.image_names)
                    title(sprintf('Image 1'))
                else
                    t{o}=format_strings_for_legend(img.image_names(1,:));
                    title(t{o});
                end
            end
    
            if ~isempty(subjects)
                title(t4, ['Post-Correction Outliers of ', subjects{sub}]);
            else
                title(t4, 'Post-Correction Outliers');
            end
    
            drawnow;

        end


    
    end

    % Save to X structure
    X.m=m_array;
    X.t=t;
    X.t_noout=t_nooutliers;
    X.out_nocorr=outlier_names;
    X.out_corr=outlier_names_corr;
end

function montage_pair_means(dat1, dat2)

% Create run means
% ----------------------------------------------------------------------
m = cell(1, 2);
m{1} = mean(dat1);
m{2} = mean(dat2);

% Set color limits for all runs together
% ----------------------------------------------------------------------

mm = cat(m{:});
alldat = mm.dat(:);

% clim = [mean(alldat) - 3*std(alldat) mean(alldat) + 3*std(alldat)];
% have to omitnan
clim = [mean(alldat, 'omitnan') - 3*std(alldat, 'omitnan') mean(alldat, 'omitnan') + 3*std(alldat, 'omitnan')];

nexttile

han = display_slices(m{1}, 'axial', 'slices_per_row', 10, 'spacing', 8, 'startslice', -30, 'endslice', 40, 'clim', clim);
if isempty(dat1.image_names)
    title(sprintf('Image 1'))
else
    t{1}=format_strings_for_legend(dat1.image_names(1,:));
    title(t{1});
end

nexttile

han = display_slices(m{2}, 'axial', 'slices_per_row', 10, 'spacing', 8, 'startslice', -30, 'endslice', 40, 'clim', clim);
if isempty(dat1.image_names)
    title(sprintf('Image 2'))
else
    t{2}=format_strings_for_legend(dat2.image_names(1,:));
    title(t{2});
end

drawnow

data=cat(m{:});

nexttile;

plot(get_wh_image(data, 1).dat, get_wh_image(data, 2).dat, 'k.'); refline

title(sprintf('r = %3.2f',  corr(get_wh_image(data, 1).dat, get_wh_image(data, 2).dat, 'Rows', 'pairwise')))
xlabel(t{1})
ylabel(t{2})


end % montage_pair_means